イントロダクション
…PaneToriのデモンストレーション

・ゲームの概要
・二人対戦
・ルール説明
・結果画面
・パネル登録

1. PaneTori制作の理由

まずは「なぜ、これを作ろうと思ったか」です。
制作物の課題一覧から、我々はテンションが上がるものを見つけられませんでした。
作っていて楽しいもの、作った後も楽しいもの、みんなの笑顔(^q^)が見られるもの……
そういった理想から、ゲームを作ろうという方針になりました。

しかし、ただゲームを作るのだけではアピール性に乏しいと判断し
ビジネス面にも意識を向けた上で、2020年の東京オリンピックをテーマと定めました。
これには、クライアントがどういった会社であるかという設定から企画を進めていきました。

この設定を基に、既存のコンシューマゲームを参考にしたゲームを作る事に決めました。
決定的な理由は、「ゲーム性を参加者全員がイメージしやすい」ことでした。



2. 直面した問題 (更新ボタン前提のゲーム)

草案となるゲームは、早くに出来上がりましたが、複数の問題が発生しました。

第１に、ゲームを設計するノウハウが通常と全く異なること。
　　　　細かいルールの変更や、テストケースのパターンの組み立て方、ゲームにおけるUIなど、すべて未知の領域でした。
　　　　
第２に、単純にゲームとして面白くないこと。
　　　　ゲームで使用するしりとりの用語、ゲームバランスの調整に難航しました。

第３に、更新ボタンやF5キーを連打しないとゲームが進まず、インタラクティブでないこと。
　　　　このため、ゲームのテンポが非常に悪く、プレイ中にストレスが溜まりました。

こういった問題が山積するにつれ、先生から受けていた忠告「ゲームは茨の道」という言葉が
国際問題のような重みを帯びるようになっていきました。



3. それを解決する技法

ゲームを設計するノウハウが通常と全く異なる事は、ゲームデザインの担当者を一人定めたことで解決しました。
担当者が中長期的なプランを持ったことで、ルールやUIの問題などをスムーズに消化できました。

ゲームとして面白くないことは、新機能として「ユーザによるパネル登録機能」を追加することで解決しました。
ユーザが自由に設定したパネルが対戦中に登場することで、混沌としたゲーム性が生まれました。

更新が必要でインタラクティブでない問題は、「サーバ・ブラウザ間での非同期通信」を用いて解決しました。
次のスライドから詳細を解説していきます。



○サーバ・ブラウザ間での非同期通信

a. ポーリング (JavaScriptにおける一定間隔での更新)

例えばチャットなどを想像してください。
サーバとブラウザの内容を同一にしたい場合、通常であれば、その都度更新を行って内容を取得する必要があります。
ブラウザから一定周期で更新を行い、サーバからデータを取得するような実装を、「ポーリング」と言います。

このポーリングは、対戦相手と画面が同期できない問題を抱えていました。

チャットであれば、相手も自分も発言なしに画面が更新されて、ネットワークに結構な負荷がかかります。


b. ロングポーリング (ブラウザからの送信後、Controllerで送信を待機)

ブラウザからサーバへ情報を取得する要請を出した後、具体的なデータの更新があるまで
サーバがデータを送り渋るような処理で遅延させ、しかるべきタイミングでデータを送信。
つまり、ブラウザから受けた要請に対して遅延でタイミングを合わせる処理を、「ロングポーリング」と言います。

チャットであれば、こちらが発言したら、相手が発言するまで画面が更新されなくなります。

ロングポーリングでは、対戦相手と画面の同期ができるようになりましたが、
サーバから一方的にデータを送信したいケースに対応できませんでした。

なので、チャットであれば、こちらが発言しない限り、画面は更新できません。


c. WebSocket (サーバ・ブラウザ間での非同期通信の確立)

ブラウザとサーバで、常に接続されたセッションを確立し、双方向からの一方的なデータの送信が可能となる。
これを実現する仕組みがWebSocketです。
これにより、サーバ側からの一方的な送信が可能になりました。

これにより、自分の発言、相手の発言、いずれのタイミングでも両者の内容が同期されます。



4. WebSocketって何？

非同期通信を行いたい場合、ポーリングやロングポーリングだとネットワークやサーバに大幅な負荷がかかります。
この無駄を省き、より少ない情報のやりとりで実現させよう規格が、WebSocketです。

これはHTTPの形でやりとりされるプロトコルであり、2011年末に発表されました。
各開発言語に提供されるAPIでもあり、対応言語が増えるまでに時間がかかりましたが、
Javaは対応済みである為、何も難しい記述をすることなく、この規格を使うことが出来ます。



5. セッション管理 (データを送信してきたユーザ、更新を送信すべきユーザの特定)

その上で、WebSocketを実装するに際して、難しい問題も生まれました。
どのユーザが問い合わせしたのかを特定する必要がでてきました。
これを特定しないと、すべてのWebSocketを確立しているブラウザに対して、同一のゲーム画面を送信してしまいます。

このため、セッションの確立と同時に、ユーザを一意に特定できる文字列であるキーを組み合わせて登録し
両者を組み合わせてサーバ内のオブジェクトを検索することで
特定のブラウザに対して合致したゲーム画面を送信できるようになりました。

これを実現できたことにより、２つの機能が実現できました。
ひとつめは、対戦を希望するユーザ同士で自動的にマッチングし、ゲーム画面に同時に移動させること。
ふたつめは、ユーザがパネルを選択したと同時に、両者のゲーム画面が、しかるべき内容で更新されること。
みっつめは、時間制限を過ぎたユーザであっても、両者のゲーム画面が、しかるべき内容で更新されること。

詳しい処理については、GitHubのアカウントを公開するので、Controllerパッケージの各WebSocketクラスをお読み下さい。



6. 質疑応答

7. 遊んでみよう


